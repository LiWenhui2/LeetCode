Index: src/leetCode_1-10.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//1 两数之和\nfunction twoSum(nums: number[], target: number): number[] {\n    //哈希表 map存储值+索引\n    const map: Map<number, number> = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(target - nums[i])) {\n            return [i, map.get(target - nums[i])!]\n        }\n        map.set(nums[i], i)\n    }\n    return []\n}\n\n// console.log(twoSum([2, 7, 11, 15], 9))\n//2. 两数相加\nclass ListNode {\n    val: number\n    next: ListNode | null\n\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = (val === undefined ? 0 : val)\n        this.next = (next === undefined ? null : next)\n    }\n}\n\nfunction addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n    const dummy: ListNode = new ListNode(0)//哑节点\n    let current: ListNode = dummy\n    let carry: number = 0//进位\n    while (l1 !== null || l2 !== null || carry !== 0) {\n        // @ts-ignore\n        const x: number = l1 ? l1.val : 0\n        // @ts-ignore\n        const y: number = l2 ? l2.val : 0\n        const sum: number = x + y + carry\n        carry = Math.floor(sum / 10)\n        current.next = new ListNode(sum % 10)//链接到原链表\n        current = current.next\n        if (l1) l1 = l1.next\n        if (l2) l2 = l2.next\n    }\n    return dummy.next\n}
===================================================================
diff --git a/src/leetCode_1-10.ts b/src/leetCode_1-10.ts
--- a/src/leetCode_1-10.ts	(revision 1774b9619cbebf20ed41363f976800f130cca68e)
+++ b/src/leetCode_1-10.ts	(date 1755185999017)
@@ -40,4 +40,22 @@
         if (l2) l2 = l2.next
     }
     return dummy.next
-}
\ No newline at end of file
+}
+
+//3. 无重复字符的最长子串
+function lengthOfLongestSubstring(s: string): number {
+    const map: Map<string, number> = new Map()
+    let maxLen: number = 0
+    let left: number = 0
+    for (let right = 0; right < s.length; right++) {
+        const char: string = s[right]
+        if (map.has(char) && map.get(char)! >= left) {
+            left = map.get(char)! + 1
+        }
+        map.set(char, right)
+        maxLen = Math.max(maxLen, right - left + 1)
+    }
+    return maxLen
+}
+
+console.log(lengthOfLongestSubstring('abba'))
\ No newline at end of file
